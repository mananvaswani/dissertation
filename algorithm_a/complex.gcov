        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/complex
        -:    0:Graph:randomUnitary.gcno
        -:    0:Data:randomUnitary.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===--------------------------- complex ----------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_COMPLEX
        -:   12:#define _LIBCPP_COMPLEX
        -:   13:
        -:   14:/*
        -:   15:    complex synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:template<class T>
        -:   21:class complex
        -:   22:{
        -:   23:public:
        -:   24:    typedef T value_type;
        -:   25:
        -:   26:    complex(const T& re = T(), const T& im = T()); // constexpr in C++14
        -:   27:    complex(const complex&);  // constexpr in C++14
        -:   28:    template<class X> complex(const complex<X>&);  // constexpr in C++14
        -:   29:
        -:   30:    T real() const; // constexpr in C++14
        -:   31:    T imag() const; // constexpr in C++14
        -:   32:
        -:   33:    void real(T);
        -:   34:    void imag(T);
        -:   35:
        -:   36:    complex<T>& operator= (const T&);
        -:   37:    complex<T>& operator+=(const T&);
        -:   38:    complex<T>& operator-=(const T&);
        -:   39:    complex<T>& operator*=(const T&);
        -:   40:    complex<T>& operator/=(const T&);
        -:   41:
        -:   42:    complex& operator=(const complex&);
        -:   43:    template<class X> complex<T>& operator= (const complex<X>&);
        -:   44:    template<class X> complex<T>& operator+=(const complex<X>&);
        -:   45:    template<class X> complex<T>& operator-=(const complex<X>&);
        -:   46:    template<class X> complex<T>& operator*=(const complex<X>&);
        -:   47:    template<class X> complex<T>& operator/=(const complex<X>&);
        -:   48:};
        -:   49:
        -:   50:template<>
        -:   51:class complex<float>
        -:   52:{
        -:   53:public:
        -:   54:    typedef float value_type;
        -:   55:
        -:   56:    constexpr complex(float re = 0.0f, float im = 0.0f);
        -:   57:    explicit constexpr complex(const complex<double>&);
        -:   58:    explicit constexpr complex(const complex<long double>&);
        -:   59:
        -:   60:    constexpr float real() const;
        -:   61:    void real(float);
        -:   62:    constexpr float imag() const;
        -:   63:    void imag(float);
        -:   64:
        -:   65:    complex<float>& operator= (float);
        -:   66:    complex<float>& operator+=(float);
        -:   67:    complex<float>& operator-=(float);
        -:   68:    complex<float>& operator*=(float);
        -:   69:    complex<float>& operator/=(float);
        -:   70:
        -:   71:    complex<float>& operator=(const complex<float>&);
        -:   72:    template<class X> complex<float>& operator= (const complex<X>&);
        -:   73:    template<class X> complex<float>& operator+=(const complex<X>&);
        -:   74:    template<class X> complex<float>& operator-=(const complex<X>&);
        -:   75:    template<class X> complex<float>& operator*=(const complex<X>&);
        -:   76:    template<class X> complex<float>& operator/=(const complex<X>&);
        -:   77:};
        -:   78:
        -:   79:template<>
        -:   80:class complex<double>
        -:   81:{
        -:   82:public:
        -:   83:    typedef double value_type;
        -:   84:
        -:   85:    constexpr complex(double re = 0.0, double im = 0.0);
        -:   86:    constexpr complex(const complex<float>&);
        -:   87:    explicit constexpr complex(const complex<long double>&);
        -:   88:
        -:   89:    constexpr double real() const;
        -:   90:    void real(double);
        -:   91:    constexpr double imag() const;
        -:   92:    void imag(double);
        -:   93:
        -:   94:    complex<double>& operator= (double);
        -:   95:    complex<double>& operator+=(double);
        -:   96:    complex<double>& operator-=(double);
        -:   97:    complex<double>& operator*=(double);
        -:   98:    complex<double>& operator/=(double);
        -:   99:    complex<double>& operator=(const complex<double>&);
        -:  100:
        -:  101:    template<class X> complex<double>& operator= (const complex<X>&);
        -:  102:    template<class X> complex<double>& operator+=(const complex<X>&);
        -:  103:    template<class X> complex<double>& operator-=(const complex<X>&);
        -:  104:    template<class X> complex<double>& operator*=(const complex<X>&);
        -:  105:    template<class X> complex<double>& operator/=(const complex<X>&);
        -:  106:};
        -:  107:
        -:  108:template<>
        -:  109:class complex<long double>
        -:  110:{
        -:  111:public:
        -:  112:    typedef long double value_type;
        -:  113:
        -:  114:    constexpr complex(long double re = 0.0L, long double im = 0.0L);
        -:  115:    constexpr complex(const complex<float>&);
        -:  116:    constexpr complex(const complex<double>&);
        -:  117:
        -:  118:    constexpr long double real() const;
        -:  119:    void real(long double);
        -:  120:    constexpr long double imag() const;
        -:  121:    void imag(long double);
        -:  122:
        -:  123:    complex<long double>& operator=(const complex<long double>&);
        -:  124:    complex<long double>& operator= (long double);
        -:  125:    complex<long double>& operator+=(long double);
        -:  126:    complex<long double>& operator-=(long double);
        -:  127:    complex<long double>& operator*=(long double);
        -:  128:    complex<long double>& operator/=(long double);
        -:  129:
        -:  130:    template<class X> complex<long double>& operator= (const complex<X>&);
        -:  131:    template<class X> complex<long double>& operator+=(const complex<X>&);
        -:  132:    template<class X> complex<long double>& operator-=(const complex<X>&);
        -:  133:    template<class X> complex<long double>& operator*=(const complex<X>&);
        -:  134:    template<class X> complex<long double>& operator/=(const complex<X>&);
        -:  135:};
        -:  136:
        -:  137:// 26.3.6 operators:
        -:  138:template<class T> complex<T> operator+(const complex<T>&, const complex<T>&);
        -:  139:template<class T> complex<T> operator+(const complex<T>&, const T&);
        -:  140:template<class T> complex<T> operator+(const T&, const complex<T>&);
        -:  141:template<class T> complex<T> operator-(const complex<T>&, const complex<T>&);
        -:  142:template<class T> complex<T> operator-(const complex<T>&, const T&);
        -:  143:template<class T> complex<T> operator-(const T&, const complex<T>&);
        -:  144:template<class T> complex<T> operator*(const complex<T>&, const complex<T>&);
        -:  145:template<class T> complex<T> operator*(const complex<T>&, const T&);
        -:  146:template<class T> complex<T> operator*(const T&, const complex<T>&);
        -:  147:template<class T> complex<T> operator/(const complex<T>&, const complex<T>&);
        -:  148:template<class T> complex<T> operator/(const complex<T>&, const T&);
        -:  149:template<class T> complex<T> operator/(const T&, const complex<T>&);
        -:  150:template<class T> complex<T> operator+(const complex<T>&);
        -:  151:template<class T> complex<T> operator-(const complex<T>&);
        -:  152:template<class T> bool operator==(const complex<T>&, const complex<T>&); // constexpr in C++14
        -:  153:template<class T> bool operator==(const complex<T>&, const T&); // constexpr in C++14
        -:  154:template<class T> bool operator==(const T&, const complex<T>&); // constexpr in C++14
        -:  155:template<class T> bool operator!=(const complex<T>&, const complex<T>&); // constexpr in C++14
        -:  156:template<class T> bool operator!=(const complex<T>&, const T&); // constexpr in C++14
        -:  157:template<class T> bool operator!=(const T&, const complex<T>&); // constexpr in C++14
        -:  158:
        -:  159:template<class T, class charT, class traits>
        -:  160:  basic_istream<charT, traits>&
        -:  161:  operator>>(basic_istream<charT, traits>&, complex<T>&);
        -:  162:template<class T, class charT, class traits>
        -:  163:  basic_ostream<charT, traits>&
        -:  164:  operator<<(basic_ostream<charT, traits>&, const complex<T>&);
        -:  165:
        -:  166:// 26.3.7 values:
        -:  167:
        -:  168:template<class T>              T real(const complex<T>&); // constexpr in C++14
        -:  169:                     long double real(long double);       // constexpr in C++14
        -:  170:                          double real(double);            // constexpr in C++14
        -:  171:template<Integral T>      double real(T);                 // constexpr in C++14
        -:  172:                          float  real(float);             // constexpr in C++14
        -:  173:
        -:  174:template<class T>              T imag(const complex<T>&); // constexpr in C++14
        -:  175:                     long double imag(long double);       // constexpr in C++14
        -:  176:                          double imag(double);            // constexpr in C++14
        -:  177:template<Integral T>      double imag(T);                 // constexpr in C++14
        -:  178:                          float  imag(float);             // constexpr in C++14
        -:  179:
        -:  180:template<class T> T abs(const complex<T>&);
        -:  181:
        -:  182:template<class T>              T arg(const complex<T>&);
        -:  183:                     long double arg(long double);
        -:  184:                          double arg(double);
        -:  185:template<Integral T>      double arg(T);
        -:  186:                          float  arg(float);
        -:  187:
        -:  188:template<class T>              T norm(const complex<T>&);
        -:  189:                     long double norm(long double);
        -:  190:                          double norm(double);
        -:  191:template<Integral T>      double norm(T);
        -:  192:                          float  norm(float);
        -:  193:
        -:  194:template<class T>      complex<T>           conj(const complex<T>&);
        -:  195:                       complex<long double> conj(long double);
        -:  196:                       complex<double>      conj(double);
        -:  197:template<Integral T>   complex<double>      conj(T);
        -:  198:                       complex<float>       conj(float);
        -:  199:
        -:  200:template<class T>    complex<T>           proj(const complex<T>&);
        -:  201:                     complex<long double> proj(long double);
        -:  202:                     complex<double>      proj(double);
        -:  203:template<Integral T> complex<double>      proj(T);
        -:  204:                     complex<float>       proj(float);
        -:  205:
        -:  206:template<class T> complex<T> polar(const T&, const T& = 0);
        -:  207:
        -:  208:// 26.3.8 transcendentals:
        -:  209:template<class T> complex<T> acos(const complex<T>&);
        -:  210:template<class T> complex<T> asin(const complex<T>&);
        -:  211:template<class T> complex<T> atan(const complex<T>&);
        -:  212:template<class T> complex<T> acosh(const complex<T>&);
        -:  213:template<class T> complex<T> asinh(const complex<T>&);
        -:  214:template<class T> complex<T> atanh(const complex<T>&);
        -:  215:template<class T> complex<T> cos (const complex<T>&);
        -:  216:template<class T> complex<T> cosh (const complex<T>&);
        -:  217:template<class T> complex<T> exp (const complex<T>&);
        -:  218:template<class T> complex<T> log (const complex<T>&);
        -:  219:template<class T> complex<T> log10(const complex<T>&);
        -:  220:
        -:  221:template<class T> complex<T> pow(const complex<T>&, const T&);
        -:  222:template<class T> complex<T> pow(const complex<T>&, const complex<T>&);
        -:  223:template<class T> complex<T> pow(const T&, const complex<T>&);
        -:  224:
        -:  225:template<class T> complex<T> sin (const complex<T>&);
        -:  226:template<class T> complex<T> sinh (const complex<T>&);
        -:  227:template<class T> complex<T> sqrt (const complex<T>&);
        -:  228:template<class T> complex<T> tan (const complex<T>&);
        -:  229:template<class T> complex<T> tanh (const complex<T>&);
        -:  230:
        -:  231:template<class T, class charT, class traits>
        -:  232:  basic_istream<charT, traits>&
        -:  233:  operator>>(basic_istream<charT, traits>& is, complex<T>& x);
        -:  234:
        -:  235:template<class T, class charT, class traits>
        -:  236:  basic_ostream<charT, traits>&
        -:  237:  operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);
        -:  238:
        -:  239:}  // std
        -:  240:
        -:  241:*/
        -:  242:
        -:  243:#include <__config>
        -:  244:#include <type_traits>
        -:  245:#include <stdexcept>
        -:  246:#include <cmath>
        -:  247:#include <sstream>
        -:  248:
        -:  249:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  250:#pragma GCC system_header
        -:  251:#endif
        -:  252:
        -:  253:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  254:
        -:  255:template<class _Tp> class _LIBCPP_TEMPLATE_VIS complex;
        -:  256:
        -:  257:template<class _Tp> complex<_Tp> operator*(const complex<_Tp>& __z, const complex<_Tp>& __w);
        -:  258:template<class _Tp> complex<_Tp> operator/(const complex<_Tp>& __x, const complex<_Tp>& __y);
        -:  259:
        -:  260:template<class _Tp>
        -:  261:class _LIBCPP_TEMPLATE_VIS complex
        -:  262:{
        -:  263:public:
        -:  264:    typedef _Tp value_type;
        -:  265:private:
        -:  266:    value_type __re_;
        -:  267:    value_type __im_;
        -:  268:public:
        -:  269:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  270:    complex(const value_type& __re = value_type(), const value_type& __im = value_type())
        -:  271:        : __re_(__re), __im_(__im) {}
        -:  272:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  273:    complex(const complex<_Xp>& __c)
        -:  274:        : __re_(__c.real()), __im_(__c.imag()) {}
        -:  275:
        -:  276:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 value_type real() const {return __re_;}
        -:  277:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 value_type imag() const {return __im_;}
        -:  278:
        -:  279:    _LIBCPP_INLINE_VISIBILITY void real(value_type __re) {__re_ = __re;}
        -:  280:    _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) {__im_ = __im;}
        -:  281:
        -:  282:    _LIBCPP_INLINE_VISIBILITY complex& operator= (const value_type& __re)
        -:  283:        {__re_ = __re; __im_ = value_type(); return *this;}
        -:  284:    _LIBCPP_INLINE_VISIBILITY complex& operator+=(const value_type& __re) {__re_ += __re; return *this;}
        -:  285:    _LIBCPP_INLINE_VISIBILITY complex& operator-=(const value_type& __re) {__re_ -= __re; return *this;}
        -:  286:    _LIBCPP_INLINE_VISIBILITY complex& operator*=(const value_type& __re) {__re_ *= __re; __im_ *= __re; return *this;}
        -:  287:    _LIBCPP_INLINE_VISIBILITY complex& operator/=(const value_type& __re) {__re_ /= __re; __im_ /= __re; return *this;}
        -:  288:
        -:  289:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator= (const complex<_Xp>& __c)
        -:  290:        {
        -:  291:            __re_ = __c.real();
        -:  292:            __im_ = __c.imag();
        -:  293:            return *this;
        -:  294:        }
        -:  295:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator+=(const complex<_Xp>& __c)
        -:  296:        {
        -:  297:            __re_ += __c.real();
        -:  298:            __im_ += __c.imag();
        -:  299:            return *this;
        -:  300:        }
        -:  301:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator-=(const complex<_Xp>& __c)
        -:  302:        {
        -:  303:            __re_ -= __c.real();
        -:  304:            __im_ -= __c.imag();
        -:  305:            return *this;
        -:  306:        }
        -:  307:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator*=(const complex<_Xp>& __c)
        -:  308:        {
        -:  309:            *this = *this * complex(__c.real(), __c.imag());
        -:  310:            return *this;
        -:  311:        }
        -:  312:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)
        -:  313:        {
        -:  314:            *this = *this / complex(__c.real(), __c.imag());
        -:  315:            return *this;
        -:  316:        }
        -:  317:};
        -:  318:
        -:  319:template<> class _LIBCPP_TEMPLATE_VIS complex<double>;
        -:  320:template<> class _LIBCPP_TEMPLATE_VIS complex<long double>;
        -:  321:
        -:  322:template<>
        -:  323:class _LIBCPP_TEMPLATE_VIS complex<float>
        -:  324:{
        -:  325:    float __re_;
        -:  326:    float __im_;
        -:  327:public:
        -:  328:    typedef float value_type;
        -:  329:
        -:  330:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(float __re = 0.0f, float __im = 0.0f)
        -:  331:        : __re_(__re), __im_(__im) {}
        -:  332:    _LIBCPP_INLINE_VISIBILITY
        -:  333:    explicit _LIBCPP_CONSTEXPR complex(const complex<double>& __c);
        -:  334:    _LIBCPP_INLINE_VISIBILITY
        -:  335:    explicit _LIBCPP_CONSTEXPR complex(const complex<long double>& __c);
        -:  336:
        -:  337:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR float real() const {return __re_;}
        -:  338:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR float imag() const {return __im_;}
        -:  339:
        -:  340:    _LIBCPP_INLINE_VISIBILITY void real(value_type __re) {__re_ = __re;}
        -:  341:    _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) {__im_ = __im;}
        -:  342:
        -:  343:    _LIBCPP_INLINE_VISIBILITY complex& operator= (float __re)
        -:  344:        {__re_ = __re; __im_ = value_type(); return *this;}
        -:  345:    _LIBCPP_INLINE_VISIBILITY complex& operator+=(float __re) {__re_ += __re; return *this;}
        -:  346:    _LIBCPP_INLINE_VISIBILITY complex& operator-=(float __re) {__re_ -= __re; return *this;}
        -:  347:    _LIBCPP_INLINE_VISIBILITY complex& operator*=(float __re) {__re_ *= __re; __im_ *= __re; return *this;}
        -:  348:    _LIBCPP_INLINE_VISIBILITY complex& operator/=(float __re) {__re_ /= __re; __im_ /= __re; return *this;}
        -:  349:
        -:  350:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator= (const complex<_Xp>& __c)
        -:  351:        {
        -:  352:            __re_ = __c.real();
        -:  353:            __im_ = __c.imag();
        -:  354:            return *this;
        -:  355:        }
        -:  356:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator+=(const complex<_Xp>& __c)
        -:  357:        {
        -:  358:            __re_ += __c.real();
        -:  359:            __im_ += __c.imag();
        -:  360:            return *this;
        -:  361:        }
        -:  362:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator-=(const complex<_Xp>& __c)
        -:  363:        {
        -:  364:            __re_ -= __c.real();
        -:  365:            __im_ -= __c.imag();
        -:  366:            return *this;
        -:  367:        }
        -:  368:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator*=(const complex<_Xp>& __c)
        -:  369:        {
        -:  370:            *this = *this * complex(__c.real(), __c.imag());
        -:  371:            return *this;
        -:  372:        }
        -:  373:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)
        -:  374:        {
        -:  375:            *this = *this / complex(__c.real(), __c.imag());
        -:  376:            return *this;
        -:  377:        }
        -:  378:};
        -:  379:
        -:  380:template<>
        -:  381:class _LIBCPP_TEMPLATE_VIS complex<double>
        -:  382:{
        -:  383:    double __re_;
        -:  384:    double __im_;
        -:  385:public:
        -:  386:    typedef double value_type;
        -:  387:
        -:  388:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(double __re = 0.0, double __im = 0.0)
     8460:  389:        : __re_(__re), __im_(__im) {}
        -:  390:    _LIBCPP_INLINE_VISIBILITY
        -:  391:    _LIBCPP_CONSTEXPR complex(const complex<float>& __c);
        -:  392:    _LIBCPP_INLINE_VISIBILITY
        -:  393:    explicit _LIBCPP_CONSTEXPR complex(const complex<long double>& __c);
        -:  394:
     9324:  395:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR double real() const {return __re_;}
     9288:  396:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR double imag() const {return __im_;}
        -:  397:
        -:  398:    _LIBCPP_INLINE_VISIBILITY void real(value_type __re) {__re_ = __re;}
        -:  399:    _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) {__im_ = __im;}
        -:  400:
        -:  401:    _LIBCPP_INLINE_VISIBILITY complex& operator= (double __re)
      108:  402:        {__re_ = __re; __im_ = value_type(); return *this;}
      162:  403:    _LIBCPP_INLINE_VISIBILITY complex& operator+=(double __re) {__re_ += __re; return *this;}
        -:  404:    _LIBCPP_INLINE_VISIBILITY complex& operator-=(double __re) {__re_ -= __re; return *this;}
        -:  405:    _LIBCPP_INLINE_VISIBILITY complex& operator*=(double __re) {__re_ *= __re; __im_ *= __re; return *this;}
        -:  406:    _LIBCPP_INLINE_VISIBILITY complex& operator/=(double __re) {__re_ /= __re; __im_ /= __re; return *this;}
        -:  407:
        -:  408:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator= (const complex<_Xp>& __c)
        -:  409:        {
        -:  410:            __re_ = __c.real();
        -:  411:            __im_ = __c.imag();
        -:  412:            return *this;
        -:  413:        }
        -:  414:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator+=(const complex<_Xp>& __c)
        -:  415:        {
      648:  416:            __re_ += __c.real();
      648:  417:            __im_ += __c.imag();
      648:  418:            return *this;
        -:  419:        }
        -:  420:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator-=(const complex<_Xp>& __c)
        -:  421:        {
      648:  422:            __re_ -= __c.real();
      648:  423:            __im_ -= __c.imag();
      648:  424:            return *this;
        -:  425:        }
        -:  426:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator*=(const complex<_Xp>& __c)
        -:  427:        {
        -:  428:            *this = *this * complex(__c.real(), __c.imag());
        -:  429:            return *this;
        -:  430:        }
        -:  431:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)
        -:  432:        {
        -:  433:            *this = *this / complex(__c.real(), __c.imag());
        -:  434:            return *this;
        -:  435:        }
        -:  436:};
        -:  437:
        -:  438:template<>
        -:  439:class _LIBCPP_TEMPLATE_VIS complex<long double>
        -:  440:{
        -:  441:    long double __re_;
        -:  442:    long double __im_;
        -:  443:public:
        -:  444:    typedef long double value_type;
        -:  445:
        -:  446:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(long double __re = 0.0L, long double __im = 0.0L)
        -:  447:        : __re_(__re), __im_(__im) {}
        -:  448:    _LIBCPP_INLINE_VISIBILITY
        -:  449:    _LIBCPP_CONSTEXPR complex(const complex<float>& __c);
        -:  450:    _LIBCPP_INLINE_VISIBILITY
        -:  451:    _LIBCPP_CONSTEXPR complex(const complex<double>& __c);
        -:  452:
        -:  453:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR long double real() const {return __re_;}
        -:  454:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR long double imag() const {return __im_;}
        -:  455:
        -:  456:    _LIBCPP_INLINE_VISIBILITY void real(value_type __re) {__re_ = __re;}
        -:  457:    _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) {__im_ = __im;}
        -:  458:
        -:  459:    _LIBCPP_INLINE_VISIBILITY complex& operator= (long double __re)
        -:  460:        {__re_ = __re; __im_ = value_type(); return *this;}
        -:  461:    _LIBCPP_INLINE_VISIBILITY complex& operator+=(long double __re) {__re_ += __re; return *this;}
        -:  462:    _LIBCPP_INLINE_VISIBILITY complex& operator-=(long double __re) {__re_ -= __re; return *this;}
        -:  463:    _LIBCPP_INLINE_VISIBILITY complex& operator*=(long double __re) {__re_ *= __re; __im_ *= __re; return *this;}
        -:  464:    _LIBCPP_INLINE_VISIBILITY complex& operator/=(long double __re) {__re_ /= __re; __im_ /= __re; return *this;}
        -:  465:
        -:  466:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator= (const complex<_Xp>& __c)
        -:  467:        {
        -:  468:            __re_ = __c.real();
        -:  469:            __im_ = __c.imag();
        -:  470:            return *this;
        -:  471:        }
        -:  472:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator+=(const complex<_Xp>& __c)
        -:  473:        {
        -:  474:            __re_ += __c.real();
        -:  475:            __im_ += __c.imag();
        -:  476:            return *this;
        -:  477:        }
        -:  478:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator-=(const complex<_Xp>& __c)
        -:  479:        {
        -:  480:            __re_ -= __c.real();
        -:  481:            __im_ -= __c.imag();
        -:  482:            return *this;
        -:  483:        }
        -:  484:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator*=(const complex<_Xp>& __c)
        -:  485:        {
        -:  486:            *this = *this * complex(__c.real(), __c.imag());
        -:  487:            return *this;
        -:  488:        }
        -:  489:    template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)
        -:  490:        {
        -:  491:            *this = *this / complex(__c.real(), __c.imag());
        -:  492:            return *this;
        -:  493:        }
        -:  494:};
        -:  495:
        -:  496:inline
        -:  497:_LIBCPP_CONSTEXPR
        -:  498:complex<float>::complex(const complex<double>& __c)
        -:  499:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  500:
        -:  501:inline
        -:  502:_LIBCPP_CONSTEXPR
        -:  503:complex<float>::complex(const complex<long double>& __c)
        -:  504:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  505:
        -:  506:inline
        -:  507:_LIBCPP_CONSTEXPR
        -:  508:complex<double>::complex(const complex<float>& __c)
        -:  509:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  510:
        -:  511:inline
        -:  512:_LIBCPP_CONSTEXPR
        -:  513:complex<double>::complex(const complex<long double>& __c)
        -:  514:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  515:
        -:  516:inline
        -:  517:_LIBCPP_CONSTEXPR
        -:  518:complex<long double>::complex(const complex<float>& __c)
        -:  519:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  520:
        -:  521:inline
        -:  522:_LIBCPP_CONSTEXPR
        -:  523:complex<long double>::complex(const complex<double>& __c)
        -:  524:    : __re_(__c.real()), __im_(__c.imag()) {}
        -:  525:
        -:  526:// 26.3.6 operators:
        -:  527:
        -:  528:template<class _Tp>
        -:  529:inline _LIBCPP_INLINE_VISIBILITY
        -:  530:complex<_Tp>
        -:  531:operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
        -:  532:{
        -:  533:    complex<_Tp> __t(__x);
        -:  534:    __t += __y;
        -:  535:    return __t;
        -:  536:}
        -:  537:
        -:  538:template<class _Tp>
        -:  539:inline _LIBCPP_INLINE_VISIBILITY
        -:  540:complex<_Tp>
        -:  541:operator+(const complex<_Tp>& __x, const _Tp& __y)
        -:  542:{
        -:  543:    complex<_Tp> __t(__x);
        -:  544:    __t += __y;
        -:  545:    return __t;
        -:  546:}
        -:  547:
        -:  548:template<class _Tp>
        -:  549:inline _LIBCPP_INLINE_VISIBILITY
        -:  550:complex<_Tp>
        -:  551:operator+(const _Tp& __x, const complex<_Tp>& __y)
        -:  552:{
        -:  553:    complex<_Tp> __t(__y);
        -:  554:    __t += __x;
        -:  555:    return __t;
        -:  556:}
        -:  557:
        -:  558:template<class _Tp>
        -:  559:inline _LIBCPP_INLINE_VISIBILITY
        -:  560:complex<_Tp>
        -:  561:operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
        -:  562:{
        -:  563:    complex<_Tp> __t(__x);
        -:  564:    __t -= __y;
        -:  565:    return __t;
        -:  566:}
        -:  567:
        -:  568:template<class _Tp>
        -:  569:inline _LIBCPP_INLINE_VISIBILITY
        -:  570:complex<_Tp>
        -:  571:operator-(const complex<_Tp>& __x, const _Tp& __y)
        -:  572:{
        -:  573:    complex<_Tp> __t(__x);
        -:  574:    __t -= __y;
        -:  575:    return __t;
        -:  576:}
        -:  577:
        -:  578:template<class _Tp>
        -:  579:inline _LIBCPP_INLINE_VISIBILITY
        -:  580:complex<_Tp>
        -:  581:operator-(const _Tp& __x, const complex<_Tp>& __y)
        -:  582:{
        -:  583:    complex<_Tp> __t(-__y);
        -:  584:    __t += __x;
        -:  585:    return __t;
        -:  586:}
        -:  587:
        -:  588:template<class _Tp>
        -:  589:complex<_Tp>
        -:  590:operator*(const complex<_Tp>& __z, const complex<_Tp>& __w)
        -:  591:{
     3240:  592:    _Tp __a = __z.real();
     3240:  593:    _Tp __b = __z.imag();
     3240:  594:    _Tp __c = __w.real();
     3240:  595:    _Tp __d = __w.imag();
     3240:  596:    _Tp __ac = __a * __c;
     3240:  597:    _Tp __bd = __b * __d;
     3240:  598:    _Tp __ad = __a * __d;
     3240:  599:    _Tp __bc = __b * __c;
     3240:  600:    _Tp __x = __ac - __bd;
     3240:  601:    _Tp __y = __ad + __bc;
     3240:  602:    if (__libcpp_isnan_or_builtin(__x) && __libcpp_isnan_or_builtin(__y))
        -:  603:    {
    #####:  604:        bool __recalc = false;
    #####:  605:        if (__libcpp_isinf_or_builtin(__a) || __libcpp_isinf_or_builtin(__b))
        -:  606:        {
    #####:  607:            __a = copysign(__libcpp_isinf_or_builtin(__a) ? _Tp(1) : _Tp(0), __a);
    #####:  608:            __b = copysign(__libcpp_isinf_or_builtin(__b) ? _Tp(1) : _Tp(0), __b);
    #####:  609:            if (__libcpp_isnan_or_builtin(__c))
    #####:  610:                __c = copysign(_Tp(0), __c);
    #####:  611:            if (__libcpp_isnan_or_builtin(__d))
    #####:  612:                __d = copysign(_Tp(0), __d);
    #####:  613:            __recalc = true;
    #####:  614:        }
    #####:  615:        if (__libcpp_isinf_or_builtin(__c) || __libcpp_isinf_or_builtin(__d))
        -:  616:        {
    #####:  617:            __c = copysign(__libcpp_isinf_or_builtin(__c) ? _Tp(1) : _Tp(0), __c);
    #####:  618:            __d = copysign(__libcpp_isinf_or_builtin(__d) ? _Tp(1) : _Tp(0), __d);
    #####:  619:            if (__libcpp_isnan_or_builtin(__a))
    #####:  620:                __a = copysign(_Tp(0), __a);
    #####:  621:            if (__libcpp_isnan_or_builtin(__b))
    #####:  622:                __b = copysign(_Tp(0), __b);
    #####:  623:            __recalc = true;
    #####:  624:        }
    #####:  625:        if (!__recalc && (__libcpp_isinf_or_builtin(__ac) || __libcpp_isinf_or_builtin(__bd) ||
    #####:  626:                          __libcpp_isinf_or_builtin(__ad) || __libcpp_isinf_or_builtin(__bc)))
        -:  627:        {
    #####:  628:            if (__libcpp_isnan_or_builtin(__a))
    #####:  629:                __a = copysign(_Tp(0), __a);
    #####:  630:            if (__libcpp_isnan_or_builtin(__b))
    #####:  631:                __b = copysign(_Tp(0), __b);
    #####:  632:            if (__libcpp_isnan_or_builtin(__c))
    #####:  633:                __c = copysign(_Tp(0), __c);
    #####:  634:            if (__libcpp_isnan_or_builtin(__d))
    #####:  635:                __d = copysign(_Tp(0), __d);
    #####:  636:            __recalc = true;
    #####:  637:        }
    #####:  638:        if (__recalc)
        -:  639:        {
    #####:  640:            __x = _Tp(INFINITY) * (__a * __c - __b * __d);
    #####:  641:            __y = _Tp(INFINITY) * (__a * __d + __b * __c);
    #####:  642:        }
    #####:  643:    }
     3240:  644:    return complex<_Tp>(__x, __y);
        -:  645:}
        -:  646:
        -:  647:template<class _Tp>
        -:  648:inline _LIBCPP_INLINE_VISIBILITY
        -:  649:complex<_Tp>
        -:  650:operator*(const complex<_Tp>& __x, const _Tp& __y)
        -:  651:{
        -:  652:    complex<_Tp> __t(__x);
        -:  653:    __t *= __y;
        -:  654:    return __t;
        -:  655:}
        -:  656:
        -:  657:template<class _Tp>
        -:  658:inline _LIBCPP_INLINE_VISIBILITY
        -:  659:complex<_Tp>
        -:  660:operator*(const _Tp& __x, const complex<_Tp>& __y)
        -:  661:{
        -:  662:    complex<_Tp> __t(__y);
        -:  663:    __t *= __x;
        -:  664:    return __t;
        -:  665:}
        -:  666:
        -:  667:template<class _Tp>
        -:  668:complex<_Tp>
        -:  669:operator/(const complex<_Tp>& __z, const complex<_Tp>& __w)
        -:  670:{
      162:  671:    int __ilogbw = 0;
      162:  672:    _Tp __a = __z.real();
      162:  673:    _Tp __b = __z.imag();
      162:  674:    _Tp __c = __w.real();
      162:  675:    _Tp __d = __w.imag();
      162:  676:    _Tp __logbw = logb(fmax(fabs(__c), fabs(__d)));
      162:  677:    if (__libcpp_isfinite_or_builtin(__logbw))
        -:  678:    {
      162:  679:        __ilogbw = static_cast<int>(__logbw);
      162:  680:        __c = scalbn(__c, -__ilogbw);
      162:  681:        __d = scalbn(__d, -__ilogbw);
      162:  682:    }
      162:  683:    _Tp __denom = __c * __c + __d * __d;
      162:  684:    _Tp __x = scalbn((__a * __c + __b * __d) / __denom, -__ilogbw);
      162:  685:    _Tp __y = scalbn((__b * __c - __a * __d) / __denom, -__ilogbw);
      162:  686:    if (__libcpp_isnan_or_builtin(__x) && __libcpp_isnan_or_builtin(__y))
        -:  687:    {
    #####:  688:        if ((__denom == _Tp(0)) && (!__libcpp_isnan_or_builtin(__a) || !__libcpp_isnan_or_builtin(__b)))
        -:  689:        {
    #####:  690:            __x = copysign(_Tp(INFINITY), __c) * __a;
    #####:  691:            __y = copysign(_Tp(INFINITY), __c) * __b;
    #####:  692:        }
    #####:  693:        else if ((__libcpp_isinf_or_builtin(__a) || __libcpp_isinf_or_builtin(__b)) && __libcpp_isfinite_or_builtin(__c) && __libcpp_isfinite_or_builtin(__d))
        -:  694:        {
    #####:  695:            __a = copysign(__libcpp_isinf_or_builtin(__a) ? _Tp(1) : _Tp(0), __a);
    #####:  696:            __b = copysign(__libcpp_isinf_or_builtin(__b) ? _Tp(1) : _Tp(0), __b);
    #####:  697:            __x = _Tp(INFINITY) * (__a * __c + __b * __d);
    #####:  698:            __y = _Tp(INFINITY) * (__b * __c - __a * __d);
    #####:  699:        }
    #####:  700:        else if (__libcpp_isinf_or_builtin(__logbw) && __logbw > _Tp(0) && __libcpp_isfinite_or_builtin(__a) && __libcpp_isfinite_or_builtin(__b))
        -:  701:        {
    #####:  702:            __c = copysign(__libcpp_isinf_or_builtin(__c) ? _Tp(1) : _Tp(0), __c);
    #####:  703:            __d = copysign(__libcpp_isinf_or_builtin(__d) ? _Tp(1) : _Tp(0), __d);
    #####:  704:            __x = _Tp(0) * (__a * __c + __b * __d);
    #####:  705:            __y = _Tp(0) * (__b * __c - __a * __d);
    #####:  706:        }
    #####:  707:    }
      162:  708:    return complex<_Tp>(__x, __y);
        -:  709:}
        -:  710:
        -:  711:template<class _Tp>
        -:  712:inline _LIBCPP_INLINE_VISIBILITY
        -:  713:complex<_Tp>
        -:  714:operator/(const complex<_Tp>& __x, const _Tp& __y)
        -:  715:{
        -:  716:    return complex<_Tp>(__x.real() / __y, __x.imag() / __y);
        -:  717:}
        -:  718:
        -:  719:template<class _Tp>
        -:  720:inline _LIBCPP_INLINE_VISIBILITY
        -:  721:complex<_Tp>
        -:  722:operator/(const _Tp& __x, const complex<_Tp>& __y)
        -:  723:{
        -:  724:    complex<_Tp> __t(__x);
        -:  725:    __t /= __y;
        -:  726:    return __t;
        -:  727:}
        -:  728:
        -:  729:template<class _Tp>
        -:  730:inline _LIBCPP_INLINE_VISIBILITY
        -:  731:complex<_Tp>
        -:  732:operator+(const complex<_Tp>& __x)
        -:  733:{
        -:  734:    return __x;
        -:  735:}
        -:  736:
        -:  737:template<class _Tp>
        -:  738:inline _LIBCPP_INLINE_VISIBILITY
        -:  739:complex<_Tp>
        -:  740:operator-(const complex<_Tp>& __x)
        -:  741:{
        -:  742:    return complex<_Tp>(-__x.real(), -__x.imag());
        -:  743:}
        -:  744:
        -:  745:template<class _Tp>
        -:  746:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  747:bool
        -:  748:operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
        -:  749:{
        -:  750:    return __x.real() == __y.real() && __x.imag() == __y.imag();
        -:  751:}
        -:  752:
        -:  753:template<class _Tp>
        -:  754:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  755:bool
        -:  756:operator==(const complex<_Tp>& __x, const _Tp& __y)
        -:  757:{
        -:  758:    return __x.real() == __y && __x.imag() == 0;
        -:  759:}
        -:  760:
        -:  761:template<class _Tp>
        -:  762:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  763:bool
        -:  764:operator==(const _Tp& __x, const complex<_Tp>& __y)
        -:  765:{
        -:  766:    return __x == __y.real() && 0 == __y.imag();
        -:  767:}
        -:  768:
        -:  769:template<class _Tp>
        -:  770:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  771:bool
        -:  772:operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
        -:  773:{
        -:  774:    return !(__x == __y);
        -:  775:}
        -:  776:
        -:  777:template<class _Tp>
        -:  778:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  779:bool
        -:  780:operator!=(const complex<_Tp>& __x, const _Tp& __y)
        -:  781:{
        -:  782:    return !(__x == __y);
        -:  783:}
        -:  784:
        -:  785:template<class _Tp>
        -:  786:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  787:bool
        -:  788:operator!=(const _Tp& __x, const complex<_Tp>& __y)
        -:  789:{
        -:  790:    return !(__x == __y);
        -:  791:}
        -:  792:
        -:  793:// 26.3.7 values:
        -:  794:
        -:  795:template <class _Tp, bool = is_integral<_Tp>::value,
        -:  796:                     bool = is_floating_point<_Tp>::value
        -:  797:                     >
        -:  798:struct __libcpp_complex_overload_traits {};
        -:  799:
        -:  800:// Integral Types
        -:  801:template <class _Tp>
        -:  802:struct __libcpp_complex_overload_traits<_Tp, true, false>
        -:  803:{
        -:  804:    typedef double _ValueType;
        -:  805:    typedef complex<double> _ComplexType;
        -:  806:};
        -:  807:
        -:  808:// Floating point types
        -:  809:template <class _Tp>
        -:  810:struct __libcpp_complex_overload_traits<_Tp, false, true>
        -:  811:{
        -:  812:    typedef _Tp _ValueType;
        -:  813:    typedef complex<_Tp> _ComplexType;
        -:  814:};
        -:  815:
        -:  816:// real
        -:  817:
        -:  818:template<class _Tp>
        -:  819:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  820:_Tp
        -:  821:real(const complex<_Tp>& __c)
        -:  822:{
       36:  823:    return __c.real();
        -:  824:}
        -:  825:
        -:  826:template <class _Tp>
        -:  827:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  828:typename __libcpp_complex_overload_traits<_Tp>::_ValueType
        -:  829:real(_Tp __re)
        -:  830:{
        -:  831:    return __re;
        -:  832:}
        -:  833:
        -:  834:// imag
        -:  835:
        -:  836:template<class _Tp>
        -:  837:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  838:_Tp
        -:  839:imag(const complex<_Tp>& __c)
        -:  840:{
        -:  841:    return __c.imag();
        -:  842:}
        -:  843:
        -:  844:template <class _Tp>
        -:  845:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -:  846:typename __libcpp_complex_overload_traits<_Tp>::_ValueType
        -:  847:imag(_Tp)
        -:  848:{
        -:  849:    return 0;
        -:  850:}
        -:  851:
        -:  852:// abs
        -:  853:
        -:  854:template<class _Tp>
        -:  855:inline _LIBCPP_INLINE_VISIBILITY
        -:  856:_Tp
        -:  857:abs(const complex<_Tp>& __c)
        -:  858:{
       18:  859:    return hypot(__c.real(), __c.imag());
        -:  860:}
        -:  861:
        -:  862:// arg
        -:  863:
        -:  864:template<class _Tp>
        -:  865:inline _LIBCPP_INLINE_VISIBILITY
        -:  866:_Tp
        -:  867:arg(const complex<_Tp>& __c)
        -:  868:{
       18:  869:    return atan2(__c.imag(), __c.real());
        -:  870:}
        -:  871:
        -:  872:template <class _Tp>
        -:  873:inline _LIBCPP_INLINE_VISIBILITY
        -:  874:typename enable_if<
        -:  875:    is_same<_Tp, long double>::value,
        -:  876:    long double
        -:  877:>::type
        -:  878:arg(_Tp __re)
        -:  879:{
        -:  880:    return atan2l(0.L, __re);
        -:  881:}
        -:  882:
        -:  883:template<class _Tp>
        -:  884:inline _LIBCPP_INLINE_VISIBILITY
        -:  885:typename enable_if
        -:  886:<
        -:  887:    is_integral<_Tp>::value || is_same<_Tp, double>::value,
        -:  888:    double
        -:  889:>::type
        -:  890:arg(_Tp __re)
        -:  891:{
        -:  892:    return atan2(0., __re);
        -:  893:}
        -:  894:
        -:  895:template <class _Tp>
        -:  896:inline _LIBCPP_INLINE_VISIBILITY
        -:  897:typename enable_if<
        -:  898:    is_same<_Tp, float>::value,
        -:  899:    float
        -:  900:>::type
        -:  901:arg(_Tp __re)
        -:  902:{
        -:  903:    return atan2f(0.F, __re);
        -:  904:}
        -:  905:
        -:  906:// norm
        -:  907:
        -:  908:template<class _Tp>
        -:  909:inline _LIBCPP_INLINE_VISIBILITY
        -:  910:_Tp
        -:  911:norm(const complex<_Tp>& __c)
        -:  912:{
      162:  913:    if (__libcpp_isinf_or_builtin(__c.real()))
    #####:  914:        return abs(__c.real());
      162:  915:    if (__libcpp_isinf_or_builtin(__c.imag()))
    #####:  916:        return abs(__c.imag());
      162:  917:    return __c.real() * __c.real() + __c.imag() * __c.imag();
      162:  918:}
        -:  919:
        -:  920:template <class _Tp>
        -:  921:inline _LIBCPP_INLINE_VISIBILITY
        -:  922:typename __libcpp_complex_overload_traits<_Tp>::_ValueType
        -:  923:norm(_Tp __re)
        -:  924:{
        -:  925:    typedef typename __libcpp_complex_overload_traits<_Tp>::_ValueType _ValueType;
        -:  926:    return static_cast<_ValueType>(__re) * __re;
        -:  927:}
        -:  928:
        -:  929:// conj
        -:  930:
        -:  931:template<class _Tp>
        -:  932:inline _LIBCPP_INLINE_VISIBILITY
        -:  933:complex<_Tp>
        -:  934:conj(const complex<_Tp>& __c)
        -:  935:{
      648:  936:    return complex<_Tp>(__c.real(), -__c.imag());
        -:  937:}
        -:  938:
        -:  939:template <class _Tp>
        -:  940:inline _LIBCPP_INLINE_VISIBILITY
        -:  941:typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
        -:  942:conj(_Tp __re)
        -:  943:{
        -:  944:    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
        -:  945:    return _ComplexType(__re);
        -:  946:}
        -:  947:
        -:  948:
        -:  949:
        -:  950:// proj
        -:  951:
        -:  952:template<class _Tp>
        -:  953:inline _LIBCPP_INLINE_VISIBILITY
        -:  954:complex<_Tp>
        -:  955:proj(const complex<_Tp>& __c)
        -:  956:{
        -:  957:    std::complex<_Tp> __r = __c;
        -:  958:    if (__libcpp_isinf_or_builtin(__c.real()) || __libcpp_isinf_or_builtin(__c.imag()))
        -:  959:        __r = complex<_Tp>(INFINITY, copysign(_Tp(0), __c.imag()));
        -:  960:    return __r;
        -:  961:}
        -:  962:
        -:  963:template <class _Tp>
        -:  964:inline _LIBCPP_INLINE_VISIBILITY
        -:  965:typename enable_if
        -:  966:<
        -:  967:    is_floating_point<_Tp>::value,
        -:  968:    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
        -:  969:>::type
        -:  970:proj(_Tp __re)
        -:  971:{
        -:  972:    if (__libcpp_isinf_or_builtin(__re))
        -:  973:        __re = abs(__re);
        -:  974:    return complex<_Tp>(__re);
        -:  975:}
        -:  976:
        -:  977:template <class _Tp>
        -:  978:inline _LIBCPP_INLINE_VISIBILITY
        -:  979:typename enable_if
        -:  980:<
        -:  981:    is_integral<_Tp>::value,
        -:  982:    typename __libcpp_complex_overload_traits<_Tp>::_ComplexType
        -:  983:>::type
        -:  984:proj(_Tp __re)
        -:  985:{
        -:  986:    typedef typename __libcpp_complex_overload_traits<_Tp>::_ComplexType _ComplexType;
        -:  987:    return _ComplexType(__re);
        -:  988:}
        -:  989:
        -:  990:// polar
        -:  991:
        -:  992:template<class _Tp>
        -:  993:complex<_Tp>
        -:  994:polar(const _Tp& __rho, const _Tp& __theta = _Tp(0))
        -:  995:{
       36:  996:    if (__libcpp_isnan_or_builtin(__rho) || signbit(__rho))
    #####:  997:        return complex<_Tp>(_Tp(NAN), _Tp(NAN));
       18:  998:    if (__libcpp_isnan_or_builtin(__theta))
        -:  999:    {
    #####: 1000:        if (__libcpp_isinf_or_builtin(__rho))
    #####: 1001:            return complex<_Tp>(__rho, __theta);
    #####: 1002:        return complex<_Tp>(__theta, __theta);
        -: 1003:    }
       18: 1004:    if (__libcpp_isinf_or_builtin(__theta))
        -: 1005:    {
    #####: 1006:        if (__libcpp_isinf_or_builtin(__rho))
    #####: 1007:            return complex<_Tp>(__rho, _Tp(NAN));
    #####: 1008:        return complex<_Tp>(_Tp(NAN), _Tp(NAN));
        -: 1009:    }
       18: 1010:    _Tp __x = __rho * cos(__theta);
       18: 1011:    if (__libcpp_isnan_or_builtin(__x))
    #####: 1012:        __x = 0;
       18: 1013:    _Tp __y = __rho * sin(__theta);
       18: 1014:    if (__libcpp_isnan_or_builtin(__y))
    #####: 1015:        __y = 0;
       18: 1016:    return complex<_Tp>(__x, __y);
       18: 1017:}
        -: 1018:
        -: 1019:// log
        -: 1020:
        -: 1021:template<class _Tp>
        -: 1022:inline _LIBCPP_INLINE_VISIBILITY
        -: 1023:complex<_Tp>
        -: 1024:log(const complex<_Tp>& __x)
        -: 1025:{
        -: 1026:    return complex<_Tp>(log(abs(__x)), arg(__x));
        -: 1027:}
        -: 1028:
        -: 1029:// log10
        -: 1030:
        -: 1031:template<class _Tp>
        -: 1032:inline _LIBCPP_INLINE_VISIBILITY
        -: 1033:complex<_Tp>
        -: 1034:log10(const complex<_Tp>& __x)
        -: 1035:{
        -: 1036:    return log(__x) / log(_Tp(10));
        -: 1037:}
        -: 1038:
        -: 1039:// sqrt
        -: 1040:
        -: 1041:template<class _Tp>
        -: 1042:complex<_Tp>
        -: 1043:sqrt(const complex<_Tp>& __x)
        -: 1044:{
       18: 1045:    if (__libcpp_isinf_or_builtin(__x.imag()))
    #####: 1046:        return complex<_Tp>(_Tp(INFINITY), __x.imag());
       18: 1047:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1048:    {
    #####: 1049:        if (__x.real() > _Tp(0))
    #####: 1050:            return complex<_Tp>(__x.real(), __libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : copysign(_Tp(0), __x.imag()));
    #####: 1051:        return complex<_Tp>(__libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : _Tp(0), copysign(__x.real(), __x.imag()));
        -: 1052:    }
       18: 1053:    return polar(sqrt(abs(__x)), arg(__x) / _Tp(2));
       18: 1054:}
        -: 1055:
        -: 1056:// exp
        -: 1057:
        -: 1058:template<class _Tp>
        -: 1059:complex<_Tp>
        -: 1060:exp(const complex<_Tp>& __x)
        -: 1061:{
        -: 1062:    _Tp __i = __x.imag();
        -: 1063:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1064:    {
        -: 1065:        if (__x.real() < _Tp(0))
        -: 1066:        {
        -: 1067:            if (!__libcpp_isfinite_or_builtin(__i))
        -: 1068:                __i = _Tp(1);
        -: 1069:        }
        -: 1070:        else if (__i == 0 || !__libcpp_isfinite_or_builtin(__i))
        -: 1071:        {
        -: 1072:            if (__libcpp_isinf_or_builtin(__i))
        -: 1073:                __i = _Tp(NAN);
        -: 1074:            return complex<_Tp>(__x.real(), __i);
        -: 1075:        }
        -: 1076:    }
        -: 1077:    else if (__libcpp_isnan_or_builtin(__x.real()) && __x.imag() == 0)
        -: 1078:        return __x;
        -: 1079:    _Tp __e = exp(__x.real());
        -: 1080:    return complex<_Tp>(__e * cos(__i), __e * sin(__i));
        -: 1081:}
        -: 1082:
        -: 1083:// pow
        -: 1084:
        -: 1085:template<class _Tp>
        -: 1086:inline _LIBCPP_INLINE_VISIBILITY
        -: 1087:complex<_Tp>
        -: 1088:pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
        -: 1089:{
        -: 1090:    return exp(__y * log(__x));
        -: 1091:}
        -: 1092:
        -: 1093:template<class _Tp, class _Up>
        -: 1094:inline _LIBCPP_INLINE_VISIBILITY
        -: 1095:complex<typename __promote<_Tp, _Up>::type>
        -: 1096:pow(const complex<_Tp>& __x, const complex<_Up>& __y)
        -: 1097:{
        -: 1098:    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
        -: 1099:    return _VSTD::pow(result_type(__x), result_type(__y));
        -: 1100:}
        -: 1101:
        -: 1102:template<class _Tp, class _Up>
        -: 1103:inline _LIBCPP_INLINE_VISIBILITY
        -: 1104:typename enable_if
        -: 1105:<
        -: 1106:    is_arithmetic<_Up>::value,
        -: 1107:    complex<typename __promote<_Tp, _Up>::type>
        -: 1108:>::type
        -: 1109:pow(const complex<_Tp>& __x, const _Up& __y)
        -: 1110:{
        -: 1111:    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
        -: 1112:    return _VSTD::pow(result_type(__x), result_type(__y));
        -: 1113:}
        -: 1114:
        -: 1115:template<class _Tp, class _Up>
        -: 1116:inline _LIBCPP_INLINE_VISIBILITY
        -: 1117:typename enable_if
        -: 1118:<
        -: 1119:    is_arithmetic<_Tp>::value,
        -: 1120:    complex<typename __promote<_Tp, _Up>::type>
        -: 1121:>::type
        -: 1122:pow(const _Tp& __x, const complex<_Up>& __y)
        -: 1123:{
        -: 1124:    typedef complex<typename __promote<_Tp, _Up>::type> result_type;
        -: 1125:    return _VSTD::pow(result_type(__x), result_type(__y));
        -: 1126:}
        -: 1127:
        -: 1128:// asinh
        -: 1129:
        -: 1130:template<class _Tp>
        -: 1131:complex<_Tp>
        -: 1132:asinh(const complex<_Tp>& __x)
        -: 1133:{
        -: 1134:    const _Tp __pi(atan2(+0., -0.));
        -: 1135:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1136:    {
        -: 1137:        if (__libcpp_isnan_or_builtin(__x.imag()))
        -: 1138:            return __x;
        -: 1139:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1140:            return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
        -: 1141:        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
        -: 1142:    }
        -: 1143:    if (__libcpp_isnan_or_builtin(__x.real()))
        -: 1144:    {
        -: 1145:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1146:            return complex<_Tp>(__x.imag(), __x.real());
        -: 1147:        if (__x.imag() == 0)
        -: 1148:            return __x;
        -: 1149:        return complex<_Tp>(__x.real(), __x.real());
        -: 1150:    }
        -: 1151:    if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1152:        return complex<_Tp>(copysign(__x.imag(), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
        -: 1153:    complex<_Tp> __z = log(__x + sqrt(pow(__x, _Tp(2)) + _Tp(1)));
        -: 1154:    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
        -: 1155:}
        -: 1156:
        -: 1157:// acosh
        -: 1158:
        -: 1159:template<class _Tp>
        -: 1160:complex<_Tp>
        -: 1161:acosh(const complex<_Tp>& __x)
        -: 1162:{
        -: 1163:    const _Tp __pi(atan2(+0., -0.));
        -: 1164:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1165:    {
        -: 1166:        if (__libcpp_isnan_or_builtin(__x.imag()))
        -: 1167:            return complex<_Tp>(abs(__x.real()), __x.imag());
        -: 1168:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1169:        {
        -: 1170:            if (__x.real() > 0)
        -: 1171:                return complex<_Tp>(__x.real(), copysign(__pi * _Tp(0.25), __x.imag()));
        -: 1172:            else
        -: 1173:                return complex<_Tp>(-__x.real(), copysign(__pi * _Tp(0.75), __x.imag()));
        -: 1174:        }
        -: 1175:        if (__x.real() < 0)
        -: 1176:            return complex<_Tp>(-__x.real(), copysign(__pi, __x.imag()));
        -: 1177:        return complex<_Tp>(__x.real(), copysign(_Tp(0), __x.imag()));
        -: 1178:    }
        -: 1179:    if (__libcpp_isnan_or_builtin(__x.real()))
        -: 1180:    {
        -: 1181:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1182:            return complex<_Tp>(abs(__x.imag()), __x.real());
        -: 1183:        return complex<_Tp>(__x.real(), __x.real());
        -: 1184:    }
        -: 1185:    if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1186:        return complex<_Tp>(abs(__x.imag()), copysign(__pi/_Tp(2), __x.imag()));
        -: 1187:    complex<_Tp> __z = log(__x + sqrt(pow(__x, _Tp(2)) - _Tp(1)));
        -: 1188:    return complex<_Tp>(copysign(__z.real(), _Tp(0)), copysign(__z.imag(), __x.imag()));
        -: 1189:}
        -: 1190:
        -: 1191:// atanh
        -: 1192:
        -: 1193:template<class _Tp>
        -: 1194:complex<_Tp>
        -: 1195:atanh(const complex<_Tp>& __x)
        -: 1196:{
        -: 1197:    const _Tp __pi(atan2(+0., -0.));
        -: 1198:    if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1199:    {
        -: 1200:        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
        -: 1201:    }
        -: 1202:    if (__libcpp_isnan_or_builtin(__x.imag()))
        -: 1203:    {
        -: 1204:        if (__libcpp_isinf_or_builtin(__x.real()) || __x.real() == 0)
        -: 1205:            return complex<_Tp>(copysign(_Tp(0), __x.real()), __x.imag());
        -: 1206:        return complex<_Tp>(__x.imag(), __x.imag());
        -: 1207:    }
        -: 1208:    if (__libcpp_isnan_or_builtin(__x.real()))
        -: 1209:    {
        -: 1210:        return complex<_Tp>(__x.real(), __x.real());
        -: 1211:    }
        -: 1212:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1213:    {
        -: 1214:        return complex<_Tp>(copysign(_Tp(0), __x.real()), copysign(__pi/_Tp(2), __x.imag()));
        -: 1215:    }
        -: 1216:    if (abs(__x.real()) == _Tp(1) && __x.imag() == _Tp(0))
        -: 1217:    {
        -: 1218:        return complex<_Tp>(copysign(_Tp(INFINITY), __x.real()), copysign(_Tp(0), __x.imag()));
        -: 1219:    }
        -: 1220:    complex<_Tp> __z = log((_Tp(1) + __x) / (_Tp(1) - __x)) / _Tp(2);
        -: 1221:    return complex<_Tp>(copysign(__z.real(), __x.real()), copysign(__z.imag(), __x.imag()));
        -: 1222:}
        -: 1223:
        -: 1224:// sinh
        -: 1225:
        -: 1226:template<class _Tp>
        -: 1227:complex<_Tp>
        -: 1228:sinh(const complex<_Tp>& __x)
        -: 1229:{
        -: 1230:    if (__libcpp_isinf_or_builtin(__x.real()) && !__libcpp_isfinite_or_builtin(__x.imag()))
        -: 1231:        return complex<_Tp>(__x.real(), _Tp(NAN));
        -: 1232:    if (__x.real() == 0 && !__libcpp_isfinite_or_builtin(__x.imag()))
        -: 1233:        return complex<_Tp>(__x.real(), _Tp(NAN));
        -: 1234:    if (__x.imag() == 0 && !__libcpp_isfinite_or_builtin(__x.real()))
        -: 1235:        return __x;
        -: 1236:    return complex<_Tp>(sinh(__x.real()) * cos(__x.imag()), cosh(__x.real()) * sin(__x.imag()));
        -: 1237:}
        -: 1238:
        -: 1239:// cosh
        -: 1240:
        -: 1241:template<class _Tp>
        -: 1242:complex<_Tp>
        -: 1243:cosh(const complex<_Tp>& __x)
        -: 1244:{
        -: 1245:    if (__libcpp_isinf_or_builtin(__x.real()) && !__libcpp_isfinite_or_builtin(__x.imag()))
        -: 1246:        return complex<_Tp>(abs(__x.real()), _Tp(NAN));
        -: 1247:    if (__x.real() == 0 && !__libcpp_isfinite_or_builtin(__x.imag()))
        -: 1248:        return complex<_Tp>(_Tp(NAN), __x.real());
        -: 1249:    if (__x.real() == 0 && __x.imag() == 0)
        -: 1250:        return complex<_Tp>(_Tp(1), __x.imag());
        -: 1251:    if (__x.imag() == 0 && !__libcpp_isfinite_or_builtin(__x.real()))
        -: 1252:        return complex<_Tp>(abs(__x.real()), __x.imag());
        -: 1253:    return complex<_Tp>(cosh(__x.real()) * cos(__x.imag()), sinh(__x.real()) * sin(__x.imag()));
        -: 1254:}
        -: 1255:
        -: 1256:// tanh
        -: 1257:
        -: 1258:template<class _Tp>
        -: 1259:complex<_Tp>
        -: 1260:tanh(const complex<_Tp>& __x)
        -: 1261:{
        -: 1262:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1263:    {
        -: 1264:        if (!__libcpp_isfinite_or_builtin(__x.imag()))
        -: 1265:            return complex<_Tp>(_Tp(1), _Tp(0));
        -: 1266:        return complex<_Tp>(_Tp(1), copysign(_Tp(0), sin(_Tp(2) * __x.imag())));
        -: 1267:    }
        -: 1268:    if (__libcpp_isnan_or_builtin(__x.real()) && __x.imag() == 0)
        -: 1269:        return __x;
        -: 1270:    _Tp __2r(_Tp(2) * __x.real());
        -: 1271:    _Tp __2i(_Tp(2) * __x.imag());
        -: 1272:    _Tp __d(cosh(__2r) + cos(__2i));
        -: 1273:    _Tp __2rsh(sinh(__2r));
        -: 1274:    if (__libcpp_isinf_or_builtin(__2rsh) && __libcpp_isinf_or_builtin(__d))
        -: 1275:        return complex<_Tp>(__2rsh > _Tp(0) ? _Tp(1) : _Tp(-1),
        -: 1276:                            __2i > _Tp(0) ? _Tp(0) : _Tp(-0.));
        -: 1277:    return  complex<_Tp>(__2rsh/__d, sin(__2i)/__d);
        -: 1278:}
        -: 1279:
        -: 1280:// asin
        -: 1281:
        -: 1282:template<class _Tp>
        -: 1283:complex<_Tp>
        -: 1284:asin(const complex<_Tp>& __x)
        -: 1285:{
        -: 1286:    complex<_Tp> __z = asinh(complex<_Tp>(-__x.imag(), __x.real()));
        -: 1287:    return complex<_Tp>(__z.imag(), -__z.real());
        -: 1288:}
        -: 1289:
        -: 1290:// acos
        -: 1291:
        -: 1292:template<class _Tp>
        -: 1293:complex<_Tp>
        -: 1294:acos(const complex<_Tp>& __x)
        -: 1295:{
        -: 1296:    const _Tp __pi(atan2(+0., -0.));
        -: 1297:    if (__libcpp_isinf_or_builtin(__x.real()))
        -: 1298:    {
        -: 1299:        if (__libcpp_isnan_or_builtin(__x.imag()))
        -: 1300:            return complex<_Tp>(__x.imag(), __x.real());
        -: 1301:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1302:        {
        -: 1303:            if (__x.real() < _Tp(0))
        -: 1304:                return complex<_Tp>(_Tp(0.75) * __pi, -__x.imag());
        -: 1305:            return complex<_Tp>(_Tp(0.25) * __pi, -__x.imag());
        -: 1306:        }
        -: 1307:        if (__x.real() < _Tp(0))
        -: 1308:            return complex<_Tp>(__pi, signbit(__x.imag()) ? -__x.real() : __x.real());
        -: 1309:        return complex<_Tp>(_Tp(0), signbit(__x.imag()) ? __x.real() : -__x.real());
        -: 1310:    }
        -: 1311:    if (__libcpp_isnan_or_builtin(__x.real()))
        -: 1312:    {
        -: 1313:        if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1314:            return complex<_Tp>(__x.real(), -__x.imag());
        -: 1315:        return complex<_Tp>(__x.real(), __x.real());
        -: 1316:    }
        -: 1317:    if (__libcpp_isinf_or_builtin(__x.imag()))
        -: 1318:        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
        -: 1319:    if (__x.real() == 0 && (__x.imag() == 0 || isnan(__x.imag())))
        -: 1320:        return complex<_Tp>(__pi/_Tp(2), -__x.imag());
        -: 1321:    complex<_Tp> __z = log(__x + sqrt(pow(__x, _Tp(2)) - _Tp(1)));
        -: 1322:    if (signbit(__x.imag()))
        -: 1323:        return complex<_Tp>(abs(__z.imag()), abs(__z.real()));
        -: 1324:    return complex<_Tp>(abs(__z.imag()), -abs(__z.real()));
        -: 1325:}
        -: 1326:
        -: 1327:// atan
        -: 1328:
        -: 1329:template<class _Tp>
        -: 1330:complex<_Tp>
        -: 1331:atan(const complex<_Tp>& __x)
        -: 1332:{
        -: 1333:    complex<_Tp> __z = atanh(complex<_Tp>(-__x.imag(), __x.real()));
        -: 1334:    return complex<_Tp>(__z.imag(), -__z.real());
        -: 1335:}
        -: 1336:
        -: 1337:// sin
        -: 1338:
        -: 1339:template<class _Tp>
        -: 1340:complex<_Tp>
        -: 1341:sin(const complex<_Tp>& __x)
        -: 1342:{
        -: 1343:    complex<_Tp> __z = sinh(complex<_Tp>(-__x.imag(), __x.real()));
        -: 1344:    return complex<_Tp>(__z.imag(), -__z.real());
        -: 1345:}
        -: 1346:
        -: 1347:// cos
        -: 1348:
        -: 1349:template<class _Tp>
        -: 1350:inline _LIBCPP_INLINE_VISIBILITY
        -: 1351:complex<_Tp>
        -: 1352:cos(const complex<_Tp>& __x)
        -: 1353:{
        -: 1354:    return cosh(complex<_Tp>(-__x.imag(), __x.real()));
        -: 1355:}
        -: 1356:
        -: 1357:// tan
        -: 1358:
        -: 1359:template<class _Tp>
        -: 1360:complex<_Tp>
        -: 1361:tan(const complex<_Tp>& __x)
        -: 1362:{
        -: 1363:    complex<_Tp> __z = tanh(complex<_Tp>(-__x.imag(), __x.real()));
        -: 1364:    return complex<_Tp>(__z.imag(), -__z.real());
        -: 1365:}
        -: 1366:
        -: 1367:template<class _Tp, class _CharT, class _Traits>
        -: 1368:basic_istream<_CharT, _Traits>&
        -: 1369:operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
        -: 1370:{
        -: 1371:    if (__is.good())
        -: 1372:    {
        -: 1373:        ws(__is);
        -: 1374:        if (__is.peek() == _CharT('('))
        -: 1375:        {
        -: 1376:            __is.get();
        -: 1377:            _Tp __r;
        -: 1378:            __is >> __r;
        -: 1379:            if (!__is.fail())
        -: 1380:            {
        -: 1381:                ws(__is);
        -: 1382:                _CharT __c = __is.peek();
        -: 1383:                if (__c == _CharT(','))
        -: 1384:                {
        -: 1385:                    __is.get();
        -: 1386:                    _Tp __i;
        -: 1387:                    __is >> __i;
        -: 1388:                    if (!__is.fail())
        -: 1389:                    {
        -: 1390:                        ws(__is);
        -: 1391:                        __c = __is.peek();
        -: 1392:                        if (__c == _CharT(')'))
        -: 1393:                        {
        -: 1394:                            __is.get();
        -: 1395:                            __x = complex<_Tp>(__r, __i);
        -: 1396:                        }
        -: 1397:                        else
        -: 1398:                            __is.setstate(ios_base::failbit);
        -: 1399:                    }
        -: 1400:                    else
        -: 1401:                        __is.setstate(ios_base::failbit);
        -: 1402:                }
        -: 1403:                else if (__c == _CharT(')'))
        -: 1404:                {
        -: 1405:                    __is.get();
        -: 1406:                    __x = complex<_Tp>(__r, _Tp(0));
        -: 1407:                }
        -: 1408:                else
        -: 1409:                    __is.setstate(ios_base::failbit);
        -: 1410:            }
        -: 1411:            else
        -: 1412:                __is.setstate(ios_base::failbit);
        -: 1413:        }
        -: 1414:        else
        -: 1415:        {
        -: 1416:            _Tp __r;
        -: 1417:            __is >> __r;
        -: 1418:            if (!__is.fail())
        -: 1419:                __x = complex<_Tp>(__r, _Tp(0));
        -: 1420:            else
        -: 1421:                __is.setstate(ios_base::failbit);
        -: 1422:        }
        -: 1423:    }
        -: 1424:    else
        -: 1425:        __is.setstate(ios_base::failbit);
        -: 1426:    return __is;
        -: 1427:}
        -: 1428:
        -: 1429:template<class _Tp, class _CharT, class _Traits>
        -: 1430:basic_ostream<_CharT, _Traits>&
        -: 1431:operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
        -: 1432:{
        -: 1433:    basic_ostringstream<_CharT, _Traits> __s;
        -: 1434:    __s.flags(__os.flags());
        -: 1435:    __s.imbue(__os.getloc());
        -: 1436:    __s.precision(__os.precision());
        -: 1437:    __s << '(' << __x.real() << ',' << __x.imag() << ')';
        -: 1438:    return __os << __s.str();
        -: 1439:}
        -: 1440:
        -: 1441:#if _LIBCPP_STD_VER > 11 
        -: 1442:// Literal suffix for complex number literals [complex.literals]
        -: 1443:inline namespace literals
        -: 1444:{ 
        -: 1445:  inline namespace complex_literals
        -: 1446:  {
        -: 1447:    constexpr complex<long double> operator""il(long double __im)
        -: 1448:    {
        -: 1449:        return { 0.0l, __im };
        -: 1450:    }
        -: 1451:
        -: 1452:    constexpr complex<long double> operator""il(unsigned long long __im)
        -: 1453:    {
        -: 1454:        return { 0.0l, static_cast<long double>(__im) };
        -: 1455:    }
        -: 1456:
        -: 1457:
        -: 1458:    constexpr complex<double> operator""i(long double __im)
        -: 1459:    {
        -: 1460:        return { 0.0, static_cast<double>(__im) };
        -: 1461:    }
        -: 1462:
        -: 1463:    constexpr complex<double> operator""i(unsigned long long __im)
        -: 1464:    {
        -: 1465:        return { 0.0, static_cast<double>(__im) };
        -: 1466:    }
        -: 1467:
        -: 1468:
        -: 1469:    constexpr complex<float> operator""if(long double __im)
        -: 1470:    {
        -: 1471:        return { 0.0f, static_cast<float>(__im) };
        -: 1472:    }
        -: 1473:
        -: 1474:    constexpr complex<float> operator""if(unsigned long long __im)
        -: 1475:    {
        -: 1476:        return { 0.0f, static_cast<float>(__im) };
        -: 1477:    }
        -: 1478:  }
        -: 1479:}
        -: 1480:#endif
        -: 1481:
        -: 1482:_LIBCPP_END_NAMESPACE_STD
        -: 1483:
        -: 1484:#endif  // _LIBCPP_COMPLEX
