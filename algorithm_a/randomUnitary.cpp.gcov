        -:    0:Source:randomUnitary.cpp
        -:    0:Graph:randomUnitary.gcno
        -:    0:Data:randomUnitary.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "header.h"
        -:    2:
        -:    3:// Modified Gram-schmidt algorithm for QR decomposition
        -:    4:// http://www.ams.sunysb.edu/~jiao/teaching/ams526_fall11/lectures/lecture06.pdf Slide 6
        -:    5:void gramSchmidt(vector<vector<complex<double>>> &a, vector<vector<complex<double>>> &q, vector<vector<complex<double>>> &r, int size) {
        2:    6:    vector<vector<complex<double>>> v;
        2:    7:    vectorMatrixInit(v, size, size);
       40:    8:    for (int j = 0; j < size; j++) {
        -:    9:        // v_j = a_j
      360:   10:        for (int k = 0; k < size; k++) {
      810:   11:            v[k][j] = a[k][j];
      162:   12:        }
       18:   13:    }
       40:   14:    for (int i = 0; i < size; i++) {
        -:   15:        // r_ii = ||v_i||_2
       54:   16:        r[i][i] = 0;
      360:   17:        for (int k = 0; k < size; k++) {
      972:   18:            r[i][i] += norm(v[k][i]);
      162:   19:        }
      108:   20:        r[i][i] = sqrt(r[i][i]);
        -:   21:
        -:   22:        // q_i = v_j/r_ii
      360:   23:        for (int k = 0; k < size; k++) {
     1296:   24:            q[k][i] = v[k][i]/r[i][i];
      162:   25:        }
        -:   26:
      180:   27:        for (int j = i + 1; j < size; j++) {
        -:   28:            // r_ij = conj(q_i) * v_j
      216:   29:            r[i][j] = 0;
     1440:   30:            for (int k = 0; k < size; k++) {
     5832:   31:                r[i][j] += conj(q[k][i]) * v[k][j];
      648:   32:            }
        -:   33:            // v_j = v_j âˆ’ r_ij * q_i
     1440:   34:            for (int k = 0; k < size; k++) {
     5184:   35:                v[k][j] -= r[i][j] * q[k][i];
      648:   36:            }
       72:   37:        }
       18:   38:    }
        -:   39:    // cout << endl << "Q is: " << endl;
        -:   40:    // printComplexMatrix(q, SIZE);
        -:   41:    // cout << endl << "R is: " << endl;
        -:   42:    // printComplexMatrix(r, SIZE);
        -:   43:
        -:   44:    // // QR MULTIPLICATION to check
        -:   45:    // vector<vector<complex<double>>> conjTrans;
        -:   46:    // vectorMatrixConjugateTranspose(q, conjTrans);
        -:   47:    //
        -:   48:    // vector<vector<complex<double>>> output;
        -:   49:    // vectorMatrixMult(q, conjTrans, output);
        -:   50:    //
        -:   51:    // cout << endl;
        -:   52:    // print2dComplexVec(output);
        -:   53:
        2:   54:}
        -:   55:
        -:   56:// Make a random unitary matrix
        -:   57:void randomUnitary(int size, vector<vector<complex<double>>> &A) {
        -:   58:
        4:   59:    random_device rd;
        4:   60:    mt19937 gen(rd());
        2:   61:    normal_distribution<> d(0,1);   // mean = 0, std dev = 1
        -:   62:
        2:   63:    vectorMatrixInit(A, size, size);
        -:   64:
       40:   65:    for(int i = 0; i < size; i++) {
      360:   66:        for (int j = 0; j < size; j++) {
      486:   67:            complex<double> temp(d(gen), d(gen));
      486:   68:            A[i][j] = temp;
      162:   69:        }
       18:   70:    }
        -:   71:
        -:   72:    // Carry out QR decomposition
        2:   73:    vector<vector<complex<double>>> q;
        2:   74:    vector<vector<complex<double>>> r;
        -:   75:
        2:   76:    vectorMatrixInit(q, size, size);
        2:   77:    vectorMatrixInit(r, size, size);
        -:   78:
        2:   79:    gramSchmidt(A, q, r, size);
        -:   80:
        -:   81:    // Create R_Diag
        2:   82:    vector<vector<complex<double>>> r_diag;
        2:   83:    vectorMatrixInit(r_diag, size, size);
       40:   84:    for (int i = 0; i < size; i++) {
      162:   85:        r_diag[i][i] = (real(r[i][i]) > 0) - (real(r[i][i]) < 0);
       18:   86:    }
        -:   87:
        -:   88:    // Random unitary matrix
        2:   89:    vector<vector<complex<double>>> randomUnitary;
        8:   90:    vectorMatrixMult(q, r_diag, randomUnitary);
        -:   91:    // matrixMult(q, r_diag, randomUnitary);
        -:   92:
        2:   93:    A = randomUnitary;
        -:   94:    // Check
        -:   95:    // complex<double> temp[SIZE][SIZE];
        -:   96:    // matrixConjugateTranspose(randomUnitary, temp);
        -:   97:    // complex<double> out[SIZE][SIZE];
        -:   98:    // matrixMult(randomUnitary, temp, out);
        -:   99:    // printComplexMatrix(out, SIZE);
        2:  100:}
        -:  101:
        -:  102:// int main(int argc, char *argv[]) {
        -:  103://     vector<vector<complex<double>>> A;
        -:  104://     randomUnitary(SIZE, A);
        -:  105://     print2dComplexVec(A);
        -:  106://     return 0;
        -:  107:// }
