\contentsline {section}{\numberline {1}Introduction}{3}
\contentsline {section}{\numberline {2}Background}{3}
\contentsline {section}{\numberline {3}Preliminaries}{4}
\contentsline {subsection}{\numberline {3.1}Binary Gray Code}{4}
\contentsline {subsection}{\numberline {3.2}Permanent of a matrix}{4}
\contentsline {subsubsection}{\numberline {3.2.1}Definition}{4}
\contentsline {subsubsection}{\numberline {3.2.2}Computing the permanent}{5}
\contentsline {section}{\numberline {4}Describing the paper and specifying the problem}{5}
\contentsline {subsection}{\numberline {4.1}Explaining the problem}{5}
\contentsline {subsubsection}{\numberline {4.1.1}Calculating the size of the sample space}{6}
\contentsline {section}{\numberline {5}The Boson Sampling Algorithm}{6}
\contentsline {subsection}{\numberline {5.1}The naive approach}{6}
\contentsline {subsection}{\numberline {5.2}Algorithm A}{7}
\contentsline {subsection}{\numberline {5.3}Algorithm B}{8}
\contentsline {section}{\numberline {6}Implementation}{11}
\contentsline {subsection}{\numberline {6.1}Original R Implementation}{11}
\contentsline {subsection}{\numberline {6.2}Implementation in C\texttt {++}}{13}
\contentsline {paragraph}{Armadillo Library:}{13}
\contentsline {subsubsection}{\numberline {6.2.1}Generating a random unitary matrix}{13}
\contentsline {subsubsection}{\numberline {6.2.2}Computing the Permanent Minors}{14}
\contentsline {paragraph}{a) Iterating $\mathbf {\delta }$ over Gray code:}{14}
\contentsline {paragraph}{b) Computing $\mathbf {v}(\mathbf {\delta }) = \{v_i (\mathbf {\delta }), i \in [m]\}$ efficiently for each $\mathbf {\delta }$:}{15}
\contentsline {paragraph}{c) Computing the partial products $\DOTSB \prod@ \slimits@ _{i \in [m] \setminus l} v_i (\delta ), \hskip 1em\relax l \in [m]$:}{15}
\contentsline {paragraph}{d) Computing the value $\left ( \DOTSB \prod@ \slimits@ _{s=1}^{m-1} \delta _s \right )$:}{16}
\contentsline {paragraph}{e) Multiplying by $\frac {1}{2^{m-2}}$ term:}{16}
\contentsline {subsubsection}{\numberline {6.2.3}Simulating exact Boson Sampling using Algorithm B}{17}
\contentsline {paragraph}{Preprocessing steps}{17}
\contentsline {paragraph}{Line 2}{17}
\contentsline {paragraph}{Line 3 and 4}{17}
\contentsline {paragraph}{Lines 6 to 11}{18}
\contentsline {paragraph}{Line 12}{18}
\contentsline {subsection}{\numberline {6.3}Running the code}{18}
\contentsline {subsection}{\numberline {6.4}Profiling the code}{19}
\contentsline {subsection}{\numberline {6.5}Parallelising the code}{20}
\contentsline {subsubsection}{\numberline {6.5.1}Parallelisation technique}{20}
\contentsline {paragraph}{a) Getting the value of the active index $j$ in the $k^{\text {th}}$ iteration:}{20}
\contentsline {paragraph}{b) Getting the value of $k^{\text {th}}$ element of the Gray code:}{21}
\contentsline {paragraph}{c) Getting the value of \mintinline {c++}{s}:}{22}
\contentsline {paragraph}{d) Computing the $\mathbf {v}$ array for iteration $k$:}{22}
\contentsline {subsubsection}{\numberline {6.5.2}Using OpenMP to modify the code for use with multiple threads}{23}
\contentsline {subsection}{\numberline {6.6}Other Oprtmisations}{24}
\contentsline {subsubsection}{\numberline {6.6.1}Compiler choice}{24}
\contentsline {paragraph}{GCC compiler: }{24}
\contentsline {paragraph}{Intel C\texttt {++} compiler: }{24}
\contentsline {subsubsection}{\numberline {6.6.2}Compiler options}{24}
\contentsline {section}{\numberline {7}Results}{25}
\contentsline {section}{\numberline {8}Further Works}{25}
\contentsline {section}{\numberline {9}Conclusion}{25}
\contentsline {section}{References}{25}
