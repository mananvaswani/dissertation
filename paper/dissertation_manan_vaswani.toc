\contentsline {section}{\numberline {1}Introduction}{3}
\contentsline {section}{\numberline {2}Background}{3}
\contentsline {section}{\numberline {3}Preliminaries}{6}
\contentsline {subsection}{\numberline {3.1}Binary Gray Code}{6}
\contentsline {subsection}{\numberline {3.2}Permanent of a matrix}{6}
\contentsline {subsubsection}{\numberline {3.2.1}Definition}{6}
\contentsline {subsubsection}{\numberline {3.2.2}Computing the permanent}{7}
\contentsline {section}{\numberline {4}Describing the paper and specifying the problem}{7}
\contentsline {subsection}{\numberline {4.1}Explaining the problem}{8}
\contentsline {subsubsection}{\numberline {4.1.1}Calculating the size of the sample space}{8}
\contentsline {section}{\numberline {5}The Boson Sampling Algorithm}{8}
\contentsline {subsection}{\numberline {5.1}The naive approach}{8}
\contentsline {subsection}{\numberline {5.2}Algorithm A}{9}
\contentsline {subsection}{\numberline {5.3}Algorithm B}{10}
\contentsline {section}{\numberline {6}Implementation}{13}
\contentsline {subsection}{\numberline {6.1}Original R Implementation}{13}
\contentsline {subsection}{\numberline {6.2}Implementation in C\texttt {++}}{15}
\contentsline {paragraph}{Armadillo Library:}{15}
\contentsline {subsubsection}{\numberline {6.2.1}Generating a random unitary matrix}{15}
\contentsline {subsubsection}{\numberline {6.2.2}Computing the Permanent Minors}{16}
\contentsline {paragraph}{a) Iterating $\mathbf {\delta }$ over Gray code:}{16}
\contentsline {paragraph}{b) Computing $\mathbf {v}(\mathbf {\delta }) = \{v_i (\mathbf {\delta }), i \in [m]\}$ efficiently for each $\mathbf {\delta }$:}{17}
\contentsline {paragraph}{c) Computing the partial products $\DOTSB \prod@ \slimits@ _{i \in [m] \setminus l} v_i (\delta ), \hskip 1em\relax l \in [m]$:}{17}
\contentsline {paragraph}{d) Computing the value $\left ( \DOTSB \prod@ \slimits@ _{s=1}^{m-1} \delta _s \right )$:}{18}
\contentsline {paragraph}{e) Multiplying by $\frac {1}{2^{m-2}}$ term:}{18}
\contentsline {subsubsection}{\numberline {6.2.3}Simulating exact Boson Sampling using Algorithm B}{19}
\contentsline {paragraph}{Preprocessing steps}{19}
\contentsline {paragraph}{Line 2}{19}
\contentsline {paragraph}{Line 3 and 4}{19}
\contentsline {paragraph}{Lines 6 to 11}{20}
\contentsline {paragraph}{Line 12}{20}
\contentsline {subsection}{\numberline {6.3}Running the code}{20}
\contentsline {subsection}{\numberline {6.4}Profiling the code}{21}
\contentsline {subsection}{\numberline {6.5}Parallelising the code}{22}
\contentsline {subsubsection}{\numberline {6.5.1}Parallelisation technique}{22}
\contentsline {paragraph}{a) Getting the value of the active index $j$ in the $k^{\text {th}}$ iteration:}{22}
\contentsline {paragraph}{b) Getting the value of $k^{\text {th}}$ element of the Gray code:}{23}
\contentsline {paragraph}{c) Getting the value of \mintinline {c++}{s}:}{24}
\contentsline {paragraph}{d) Computing the $\mathbf {v}$ array for iteration $k$:}{24}
\contentsline {subsubsection}{\numberline {6.5.2}Using OpenMP to modify the code for use with multiple threads}{25}
\contentsline {subsection}{\numberline {6.6}Other Oprtmisations}{26}
\contentsline {subsubsection}{\numberline {6.6.1}Compiler choice}{26}
\contentsline {paragraph}{GCC compiler: }{26}
\contentsline {paragraph}{Intel C\texttt {++} compiler: }{26}
\contentsline {subsubsection}{\numberline {6.6.2}Compiler options}{26}
\contentsline {section}{\numberline {7}Results}{27}
\contentsline {section}{\numberline {8}Further Works}{27}
\contentsline {section}{\numberline {9}Conclusion}{27}
\contentsline {section}{References}{27}
